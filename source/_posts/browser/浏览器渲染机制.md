---
title: 浏览器渲染机制——转+补充
date: 2016-08-02 15:02:34
categories: 浏览器原理
tags: [chrome]
---

> 本来想自己总结来着，结果网上的有篇文章，写的太好了，直接拿过来学习了

[Google Web Fundamentals](https://developers.google.com/web/fundamentals/?hl=en) 是一个非常优秀的文档，里面讲到了跟web、浏览器、前端的方方面面。我总结一下其中的 Ilya Grigorik 写的 [Critical rendering path](https://developers.google.com/web/fundamentals/performance/critical-rendering-path/?hl=en) 浏览器渲染机制部分的内容如下：

### 几个概念
-----------
* 1、[DOM](https://developers.google.com/web/fundamentals/performance/critical-rendering-path/constructing-the-object-model?hl=en#document-object-model-dom)：Document Object Model，浏览器将HTML解析成树形的数据结构，简称DOM。

* 2、[CSSOM](https://developers.google.com/web/fundamentals/performance/critical-rendering-path/constructing-the-object-model?hl=en#css-object-model-cssom)：CSS Object Model，浏览器将CSS代码解析成树形的数据结构。

* 3、DOM 和 CSSOM 都是以 Bytes → characters → tokens → nodes → object model.这样的方式生成最终的数据。如下图所示： 
<!-- more -->
![](http://delai.me/code/content/images/2016/01/full-process.png?_=5152072)
DOM树的构建过程是一个深度遍历过程：当前节点的所有子节点都构建好后才会去构建当前节点的下一个兄弟节点。

* 4、Render Tree：DOM 和 CSSOM 合并后生成 Render Tree，如下图： 
![](http://delai.me/code/content/images/2016/01/render-tree-construction.png?_=5152072)
Render Tree 和DOM一样，以多叉树的形式保存了每个节点的css属性、节点本身属性、以及节点的孩子节点。

*注意：display:none 的节点不会被加入Render Tree，而visibility: hidden 则会，所以，如果某个节点最开始是不显示的，设为display:none是更优的。具体可以看这里*

### 浏览器的渲染过程
-----------
* 1、Create/Update DOM And request css/image/js：浏览器请求到HTML代码后，在生成DOM的最开始阶段（应该是 Bytes → characters 后），并行发起css、图片、js的请求，无论他们是否在HEAD里。

注意：发起js文件的下载request并不需要DOM处理到那个script节点，比如：简单的正则匹配就能做到这一点，虽然实际上并不一定是通过正则：）。这是很多人在理解渲染机制的时候存在的误区

* 2、Create/Update Render CSSOM：CSS文件下载完成，开始构建CSSOM

* 3、Create/Update Render Tree：所有CSS文件下载完成，CSSOM构建结束后，和 DOM 一起生成 Render Tree。

* 4、Layout：有了Render Tree，浏览器已经能知道网页中有哪些节点、各个节点的CSS定义以及他们的从属关系。下一步操作称之为Layout，顾名思义就是计算出每个节点在屏幕中的位置。

* 5、Painting：Layout后，浏览器已经知道了哪些节点要显示（which nodes are visible）、每个节点的CSS属性是什么（their computed styles）、每个节点在屏幕中的位置是哪里（geometry）。就进入了最后一步：Painting，按照算出来的规则，通过显卡，把内容画到屏幕上。

以上五个步骤前3个步骤之所有使用 “Create/Update” 是因为DOM、CSSOM、Render Tree都可能在第一次Painting后又被更新多次，比如JS修改了DOM或者CSS属性。

Layout 和 Painting 也会被重复执行，除了DOM、CSSOM更新的原因外，图片下载完成后也需要调用Layout 和 Painting来更新网页。

![](https://loulanyijian.github.io/images/render.png)

### 看Timeline，一目了然
-----------
我扒了一段有赞PC首页的代码到本地，通过Node跑起来。Node作为Server端，对`/js/jquery.js` 做了延时2s返回的处理，并且把`<script src="http://127.0.0.1:8080/js/jquery.js"></script>` 放到导航栏的下面，结果是这样的：
![](http://delai.me/code/content/images/2016/01/1----.png?_=5152072)
![](http://delai.me/code/content/images/2016/01/2---painting.jpg?_=5152072)
![](http://delai.me/code/content/images/2016/01/3jquery--.png?_=5152072)
![](http://delai.me/code/content/images/2016/01/4load.png?_=5152072)
从上面的Timeline我们可以看出：

首屏时间和DomContentLoad事件没有必然的先后关系
* 所有CSS尽早加载是减少首屏时间的最关键
* js的下载和执行会阻塞Dom树的构建（严谨地说是中断了Dom树的更新），所以script标签放在首屏范围内的HTML代码段里会截断首屏的内容。
* script标签放在body底部，做与不做async或者defer处理，都不会影响首屏时间，但影响DomContentLoad和load的时间，进而影响依赖他们的代码的执行的开始时间。


[原文链接-http://www.cnblogs.com/CrabMan/p/5152072.html](http://www.cnblogs.com/CrabMan/p/5152072.html)



